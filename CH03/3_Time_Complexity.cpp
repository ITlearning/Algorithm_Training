// 시간 복잡도
// 알고리즘에서의 시간 복잡도는 입력의 크기가 커질때 수행시간이 어떤속도로 증가하는지를 나타내는 개념이다.
// 시간 복잡도는 O(...)으로 표기하며,괄호 안에는 어떤 함수가 들어가게된다.
// 보통 괄호 안에는 n으로 입력의 크기를 나타낸다.

// O(1) : 코드가 단일 명령어로 되어 있을경우
int a,b,c;
a++;
b++;
c = a + b;
// 이럴 경우에는 단일 명령어로 처리하기 때문에 1로 표기한다.

// O(n) : 반복문 안의 내용이 n번 수행될때
for(int i = 0; i < n; i++) {
	// 반복 수행
}
// n번 수행되기 때문에 O(n)이다.


// O(n^2) : 반복문 안의 내용이 n^2번 수행될때
for(int i = 0; i <= n; i++) {
	for(int j = 0; j <= n; j++) {
		// 반복 수행
	}
}
// 반복문을 2번 중첩 수행하기 때문에 n^2이 된다.
// 일반적으로, 반복문이 k중으로 중첩되어 있으며 각 반복문이 n번씩 수행된다면, 그 시간 복잡도는 O(n^k)이다.


// 시간복잡도가 반복문 내부의 수행 횟수를 정확하게 알려주지는 않는다.
// 그 이유는 함수의 차수만 중요하고 나머지 상수 인자들은 무시하기 때문.

// 다음 세 개의 코드는 각각 3n, n + 5, n/2 번씩 수행되는 예제이다.
// 하지만, 코드의 시간 복잡도는 모두 O(n)이다.
for(int i = 1; i <= 3*n; i++) {
	// 3n번 수행
}

for(int i = 1; i <= n+5; i++) {
	// n+5번 수행
}

for(int i = 1; i <= n; i += 2) {
	// n/2번 수행
}


// 이 코드는 수행시간이 O(n^2)이다.

for(int i = 1; i <= n; i++) {
	for(int j = 1; j <= i; j++) {
		
	}
}


// 만일 알고리즘이 여러 단계가 연달아 있는 경우, 전체 시간 복잡도는 가장 큰 시간으로 책정된다.
// 그 이유는 가장 느린 단계가 알고리즘의 병목이 되기 때문이다.

// 예를 들어 O(n), O(n^2) 이 연달아 있는 경우, 전체 시간 복잡도는 O(n^2)이 된다.



// 시간 복잡도는 여러 인자에 영향을 받는데, 다음과 같은 코드에서는 시간복잡도가 O(nm)이 된다.

for(int i = 1; i <= n; i++) {
	for(int j = 1; j <= m; j++) {
		// nm 반복수행
	}
}



// 재귀함수의 시간 복잡도는 함수가 몇번 호출되는지, 각 호출시에 시간 복잡도가 어떻게 되는지에 따라 결정이된다.
// 전체 시간 복잡도는 이 둘을 곱한 형태가 된다.

void f(int n) {
	if(n == 1) return;
	f(n-1);
}

// f(n)을 수행하면 함수호출이 n번 발생하고, 각 호출의 시간복잡도는 O(1)이다.
// 따라서 전체 시간 복잡도는 O(n)이다. (n * 1)

void g(int n) {
	if(n == 1) return;
	g(n - 1);
	g(n - 1);
}

// 인자를 n으로 주고 이 함수를 호출한다면?
// 인자가 n-1 인 함수 호출이 두번 일어나고, n-2인 함수 호출은 네번, n-3은 여덟번..
// 이를 일반화하면 , 인자가 n-k인 함수 호출은 n^2번 일어나고, 이때 k = 0,1,2,3... n-1이다.
// 따라서 시간복잡도는 O(n^2)이다.